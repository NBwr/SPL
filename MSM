# Middle Square Method
# Following code consists of three approaches towards the MSM-algorithm


msm = function(seed, n){
  a = nchar(seed)
  empty.vec = NULL
  for(i in 1:n) {
    seedseed = seed^2
    seed = (seedseed %/% 10^(a/2)) %% 10^a
    empty.vec = c(empty.vec, seed)
  }   
  return(empty.vec)
}


# Takes all even digit-long seeds as an input

msm1 = function(my_seed, n){ #my_seed is the initial seed, n is the number of generated random numbers
  a = nchar(my_seed)
  b = a/2+1 
  c = a/2+a
  rangeit = vector(length = n)
  for(i in 1:n){
    my_seed = as.numeric( 
      unlist(
        strsplit(
          str_pad(
            my_seed * my_seed, a*2, pad = "0"), # So far I have not been able to add leading zeroes in a simpler way
          "")
        )
      )
    if(length(my_seed) == a*2){
      my_seed = my_seed[b:c]    
    } 
    rangeit[i] = my_seed = as.numeric(paste(my_seed, sep = "", collapse = ""))
    #    rangeit[i] = rangeit[i]/999999 #If interval should be on [0,1]
  }
  return(rangeit)
}


# Basically as the second approach, but using pipe operators 
# Drawback: makes it much slower, see system.time
msm2 = function(my_seed, n){
  a = nchar(my_seed)
  b = a/2+1
  c = a/2+a
  rangeit = vector(length = n)
  for(i in 1:n){
    my_seed = my_seed^2%>%str_pad(a*2, pad = "0") %>%
    strsplit(.,"") %>%
    unlist %>%
    as.numeric
    if(length(my_seed) == a*2){
      my_seed = my_seed[b:c]    
    } 
    rangeit[i] = my_seed = as.numeric(paste(my_seed, sep = "", collapse = ""))
    #    rangeit[i] = rangeit[i]/999999 #If interval should be on [0,1]
  }
  return(rangeit)
}

# Checks the run time of all three functions
system.time(msm(123456,10000))
system.time(msm1(123456,10000))
system.time(msm2(123456,10000))
